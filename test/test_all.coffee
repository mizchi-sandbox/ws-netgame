## ge.js ##
# generated by src/core.coffee
class Game
  constructor: (conf) ->
    Sys::message("Welcome to the world!")
    @players=[]
    @stage = new RandomStage(@,32)
    @objs = []
    @frame_count = 0

  enter: ->
    obj.update(@objs, @map) for obj in @objs
    @stage.update @objs
    @frame_count++

  join_player : (uname)->
    # @scene.add_player(uname)

  start: () ->
    @pid = setInterval =>
      @scene.enter()
    , 1000/30

  stop :->
    clearInterval @pid

maps = require './maps'

class RandomStage extends maps.Stage
  constructor: (@context , @cell=32) ->
    super @cell
    @_map = create_map 80,50,10
    @max_object_count = 18
    @frame_count = 0


  update:(objs)->
    @sweep(objs)
    @pop_monster(objs)

  sweep: (objs)->
    for i in [0 ... objs.length]
      if objs[i].is_dead() and objs[i].cnt > 120
        objs.splice(i,1)
        break

  pop_monster: (objs) ->
    # リポップ条件確認
    if objs.length < @max_object_count and @frame_count % 60*3 == 0
      random_point  = @get_rand_xy()
      if Math.random() < 0.9
        group = (if Math.random() > 0.05 then ObjectGroup.Enemy else ObjectGroup.Player )
        objs.push( new Goblin(random_point.x, random_point.y, group) )
      else
        objs.push( new MoneyObject(random_point.x, random_point.y) )


exports.Game = Game
# generated by src/sprites.coffee
class Sprite
  constructor: (@x=0,@y=0,@scale=10) ->
  get_distance: (target)->
    xd = Math.pow (@x-target.x) ,2
    yd = Math.pow (@y-target.y) ,2
    return Math.sqrt xd+yd

  getpos_relative:(cam)->
    pos =
      vx : 320 + @x - cam.x
      vy : 240 + @y - cam.y

  find_obj:(group_id,targets, range)->
    targets.filter (t)=>
      t.group is group_id and @get_distance(t) < range

  is_targeted:(objs)->
     @ in (i.targeting_obj? for i in objs)

  has_target:()->
    false

  is_following:()->
    false

  is_alive:()->
    false
  is_dead:()->
    not @is_alive()

  find_obj:(group_id,targets, range)->
    targets.filter (t)=>
      t.group is group_id and @get_distance(t) < range and t.is_alive()

ObjectGroup =
  Player : 0
  Enemy  : 1
  Item   : 2
  is_battler : (group_id)->
    group_id in [@Player, @Enemy]
  get_against : (obj)->
    switch obj.group
      when @Player
        return @Enemy
      when @Enemy
        return @Player

class ItemObject extends Sprite
  size : 10
  is_alive:()->
    @event_in
  is_dead:()->
    not @is_alive()

  constructor: (@x=0,@y=0) ->
    @cnt = 0
    @group = ObjectGroup.Item
    @event_in = true

  update:(objs,map)->
    @cnt++
      # if @event_in
      #   @event(objs,map,camera)
      #   @event_in = false
      #   @cnt=0

  event : (objs,map)->
    console.log "you got item"


class HealObject extends ItemObject
  event : (objs,map , keys ,mouse,player)->
    player.status.hp += 30
    player.check()

class MoneyObject extends ItemObject
  constructor:(x,y)->
    super(x,y)
    @amount = randint(0,100)
  event : (objs,map, player)->
    GameData.gold += @amount
    Sys::message "You got #{@amount}G / #{GameData.gold} "

class TresureObject extends ItemObject
  constructor:(x,y)->
    super(x,y)
    @potential = randint(0,100)
  event : (objs,map , keys ,mouse,player)->
    Sys::message "You got a item#{@potential}"

GameData =
  gold : 0
  items : []

Sys = new Object
Sys.prototype =
  message : (text)->
    console.log "[Message] #{text}"

  debug: (text)->
    console.log " -*- #{text}"
# generated by src/maps.coffee
{pow,sqrt,abs,random,max,min} = Math

class Room
  constructor:(@map,@depth, @ax,@ay)->
    @max_size = 4
    @next = null
    if @depth > 0
      @next = @split()

    if @ax[1]-@ax[0] < 13
      @rx = @ax
    else
      cx = ~~((@ax[0]+@ax[1])/2)
      @rx = [cx-6, cx+6]
    if @ay[1]-@ay[0] < 13
      @ry = @ay
    else
      cy = ~~((@ay[0]+@ay[1])/2)
      @ry = [cy-6, cy+6]

    @center = [
      ~~((@rx[1]+@rx[0])/2)
      ~~((@ry[1]+@ry[0])/2)
    ]

    @draw_area()

  _v : ->
    [sx,ex] = @ax
    cx = ~~((ex-sx)*(1-random()/@depth)+sx)
    @ax = [cx,ex]
    new Room @map,--@depth, [sx,cx ],@ay

  _s : ->
    [sy , ey] = @ay
    cy = ~~( (ey-sy)*(1-random()/@depth)+sy  )
    @ay = [cy,ey]
    new Room @map,--@depth, @ax , [sy,cy]

  split:->
    if Math.random() > 0.5
      @_s()
    else
      @_v()

  draw_area : ->
    [sx,ex] = @rx
    [sy,ey] = @ry
    for i in [sx ... ex]
      for j in [sy ... ey]
        if (i == sx or i == (ex-1) ) or (j == sy or j == (ey-1))
          @map[i][j] = 1
        else
          @map[i][j] = 0

  draw_path : ->
    if @next
      [cx,cy] = @center
      [nx,ny] = @next.center
      while abs(cx-nx)+abs(cy-ny) > 0
        if cx>nx then cx--
        else if cx<nx then cx++
        else if cy>ny then cy--
        else if cy<ny then cy++
        @map[cx][cy] = 0
      @next.draw_path()

class Node
  start: [null,null]
  goal: [null,null]
  constructor:(pos)->
    @pos    = pos
    @owner_list  = null
    @parent = null
    @hs     = Math.pow(pos[0]-@goal[0],2)+Math.pow(pos[1]-@goal[1],2)
    @fs     = 0

  is_goal:(self)->
    return @goal == @pos

class Stage extends Sprite
  constructor: (@cell=32) ->
    super 0, 0, @cell
    # @_map = @load(maps.debug)

  find:(arr,pos)->
    for i in arr
      if i.pos[0] == pos[0] and i.pos[1] == pos[1]
        return i
    return null

  load : (text)->
    tmap = text.replaceAll(".","0").replaceAll(" ","1").split("\n")
    max = Math.max.apply null,(row.length for row in tmap)
    map = []
    for y in [0...tmap.length]
      map[y]= ((if i < tmap[y].length then parseInt tmap[y][i] else 1) for i in [0 ... max])

    map = @_rotate90(map)
    map = @_set_wall(map)
    return map

  gen_random_map:(x,y)->
    map = []
    for i in [0 ... x]
      map[i] = []
      for j in [0 ... y]
        if (i == 0 or i == (x-1) ) or (j == 0 or j == (y-1))
          map[i][j] = 1
        else if Math.random() < 0.2
          map[i][j] = 1
        else
          map[i][j] = 0
    return map

  get_point: (x,y)->
    return {x:~~((x+1/2) *  @cell ),y:~~((y+1/2) * @cell) }

  get_cell: (x,y)->
    x = ~~(x / @cell)
    y = ~~(y / @cell)
    return {x:x,y:y}

  get_rand_cell_xy : ()->
    rx = ~~(Math.random()*@_map.length)
    ry = ~~(Math.random()*@_map[0].length)
    if @_map[rx][ry]
      return @get_rand_cell_xy()
    return [rx,ry]

  get_rand_xy: ()->
    rx = ~~(Math.random()*@_map.length)
    ry = ~~(Math.random()*@_map[0].length)
    if @_map[rx][ry]
      return @get_rand_xy()
    return @get_point(rx,ry)


  collide: (x,y)->
    x = ~~(x / @cell)
    y = ~~(y / @cell)
    return @_map[x][y]

  search_path: (start,goal)->
    path = []
    Node::start = start
    Node::goal = goal
    open_list = []
    close_list = []

    start_node = new Node(Node::start)
    start_node.fs = start_node.hs
    open_list.push(start_node)

    search_path =[
      [-1,-1], [ 0,-1], [ 1,-1]
      [-1, 0]         , [ 1, 0]
      [-1, 1], [ 0, 1], [ 1, 1]
    ]

    max_depth = 100
    for _ in [1..max_depth]
      return [] if open_list.size() < 1 #探索失敗

      open_list.sort( (a,b)->a.fs-b.fs )
      min_node = open_list[0]
      close_list.push( open_list.shift() )

      if min_node.pos[0] is min_node.goal[0] and min_node.pos[1] is min_node.goal[1]
        path = []
        n = min_node
        while n.parent
          path.push(n.pos)
          n = n.parent
        return path.reverse()

      n_gs = min_node.fs - min_node.hs

      for i in search_path # 8方向探索
        [nx,ny] = [i[0]+min_node.pos[0] , i[1]+min_node.pos[1]]
        if not @_map[nx][ny]
          dist = Math.pow(min_node.pos[0]-nx,2) + Math.pow(min_node.pos[1]-ny,2)

          if obj = @find(open_list,[nx,ny])
            if obj.fs > n_gs+obj.hs+dist
              obj.fs = n_gs+obj.hs+dist
              obj.parent = min_node
          else if obj = @find(close_list,[nx,ny])
            if obj.fs > n_gs+obj.hs+dist
                obj.fs = n_gs+obj.hs+dist
                obj.parent = min_node
                open_list.push(obj)
                close_list.remove(obj)
          else
            n = new Node([nx,ny])
            n.fs = n_gs+n.hs+dist
            n.parent = min_node
            open_list.push(n)
    return []

  _rotate90:(map)->
    res = []
    for i in [0...map[0].length]
      res[i] = ( j[i] for j in map)
    res

  _set_wall:(map)->
    x = map.length
    y = map[0].length
    map[0] = (1 for i in [0...map[0].length])
    map[map.length-1] = (1 for i in [0...map[0].length])
    for i in map
      i[0]=1
      i[i.length-1]=1
    map


blank = (x,y)->
  map = []
  for i in [0 ... x]
    map[i] = []
    for j in [0 ... y]
      map[i][j] = 1
  return map

create_map = (x,y,depth)->
  root = new Room(blank(x,y),depth ,[1,x-1],[1,y-1])
  root.draw_path()
  root.map

randint = (from,to) ->
  if not to?
    to = from
    from = 0
  return ~~( Math.random()*(to-from+1))+from


# rjoin = (map1,map2)->
#   return map1.concat(map2)

# sjoin = (map1,map2)->
#   if not map1[0].length == map2[0].length
#     return false
#   y = 0
#   buf = []
#   for i in [0...map1.length]
#     buf[i] = map1[i].concat(map2[i])
#     y++
#   return buf

# generated by src/char.coffee
class Character extends Sprite
  scale : null
  state : null
  following_obj: null
  targeting_obj: null
  status : {}
  _items_ : []

  constructor: (@x=0,@y=0,@group=ObjectGroup.Enemy ,status={}) ->
    super @x, @y
    @state =
      active : false
    @targeting_obj = null
    @dir = 0
    @cnt = 0
    @id = ~~(Math.random() * 100)
    @animation = []
    @cnt = ~~(Math.random() * 60)
    @distination = [@x,@y]
    @_path = []

  regenerate: ()->
    r = (if @targeting_obj then 2 else 1)
    if @is_alive()
      if @status.hp < @status.MAX_HP
        @status.hp += 1

  update:(objs, cmap)->
    @cnt += 1
    if @is_alive()
      @check()
      @regenerate() if @cnt%60 == 0
      @search objs
      @move(objs,cmap)
      @change_skill()
      @selected_skill.update(objs)

  search : (objs)->
    enemies = @find_obj(ObjectGroup.get_against(@),objs,@status.sight_range)
    if @has_target()
      if @targeting_obj.is_dead() or @get_distance(@targeting_obj) > @status.sight_range*1.5
        # ターゲットが死 or 感知外
        Sys::message "#{@name} lost track of #{@targeting_obj.name}"
        @targeting_obj = null
    else if enemies.size() > 0
      # 新たに目視した場合
      @targeting_obj = enemies[0]
      Sys::message "#{@name} find #{@targeting_obj.name}"

  move: (objs ,cmap)->
    # for wait
    if @has_target()
      @set_dir(@targeting_obj.x,@targeting_obj.y)
      return if @get_distance(@targeting_obj) < @selected_skill.range
    else
      return if @cnt%60 < 15

    if @has_target() and @cnt%60 is 0
      @_update_path(cmap)

    if @to
    # 目的地が設定されてる場合
      dp = cmap.get_point(@to[0],@to[1])
      [nx,ny] = @_trace( dp.x , dp.y )
      wide = @status.speed
      if dp.x-wide<nx<dp.x+wide and dp.y-wide<ny<dp.y+wide
        if @_path.length > 0
          @to = @_path.shift()
        else
          @to = null
    else
      if @has_target()
        @_update_path(cmap)
      else
        c = cmap.get_cell(@x,@y)
        @to = [c.x+randint(-1,1),c.y+randint(-1,1)]

    if not cmap.collide( nx,ny )
      @x = nx if nx?
      @y = ny if ny?

    if @x is @_lx_ and @y is @_ly_
      c = cmap.get_cell(@x,@y)
      @to = [c.x+randint(-1,1),c.y+randint(-1,1)]
    @_lx_ = @x
    @_ly_ = @y

  equip : (item)->
    if item.at in (k for k,v of @_equips_)
      @_equips_[item.at] = item
    false

  get_item:(item)->
    @_items_.push(item)

  use_item:(item)->
    @_items_.remove(item)

  get_param:(param)->
    (item?[param] or 0 for at,item of @_equips_).reduce (x,y)-> x+y

  die : (actor)->
    @cnt = 0
    if @group == ObjectGroup.Enemy
      gold = randint(0,100)
      GameData.gold += gold
    actor.status.get_exp(@status.lv*10)
    Sys::message "#{@name} is killed by #{actor.name}." if actor
    Sys::message "You got #{gold}G." if gold

  add_damage : (actor, amount)->
    before = @is_alive()
    @status.hp -= amount
    @die(actor) if @is_dead() and before
    return @is_alive()

  set_skill :()->
    for k,v of @keys
      if v and k in ["zero","one","two","three","four","five","six","seven","eight","nine"]
        @selected_skill = @skills[k]
        break

  _update_path : (cmap)->
    @_path = @_get_path(cmap)
    @to = @_path.shift()

  _get_path:(map)->
    from = map.get_cell( @x ,@y)
    to = map.get_cell( @targeting_obj.x ,@targeting_obj.y)
    return map.search_path( [from.x,from.y] ,[to.x,to.y] )

  _trace: (to_x , to_y)->
    @set_dir(to_x,to_y)
    return [
      @x + ~~(@status.speed * Math.cos(@dir)),
      @y + ~~(@status.speed * Math.sin(@dir))
    ]


  has_target:()->
    if @targeting_obj isnt null then true else false

  is_following:()->
    if @following_obj isnt null then true else false

  is_alive:()->
    return @status.hp > 1

  is_dead:()->
    not @is_alive()

  find_obj:(group_id,targets, range)->
    targets.filter (t)=>
      t.group is group_id and @get_distance(t) < range and t.is_alive()

  set_dir: (x,y)->
    rx = x - @x
    ry = y - @y
    if rx >= 0
      @dir = Math.atan( ry / rx  )
    else
      @dir = Math.PI - Math.atan( ry / - rx  )

  check:()->
    @status.hp = @status.MAX_HP if @status.hp > @status.MAX_HP
    @status.hp = 0 if @status.hp < 0
    if @is_alive()
      if @targeting_obj?.is_dead()
         @targeting_obj = null
    else
      @targeting_obj = null

  shift_target:(targets)->
    if @has_target() and targets.length > 0
      if not @targeting_obj in targets
        @targeting_obj = targets[0]
        return
      else if targets.size() == 1
        @targeting_obj = targets[0]
        return
      if targets.size() > 1
        cur = targets.indexOf @targeting_obj
        if cur+1 >= targets.size()
          cur = 0
        else
          cur += 1
        @targeting_obj = targets[cur]

  add_animation:(animation)->
    @animation.push(animation)

class Goblin extends Character
  name : "Goblin"
  scale : 1
  constructor: (@x,@y,@group) ->
    @dir = 0
    @status = new Status
      str: 8
      int: 4
      dex: 6
    super(@x,@y,@group,@status)
    @skills =
      one: new Skill_Atack(@,3)
      two: new Skill_Heal(@)
    @selected_skill = @skills['one']
    @_equips_ =
      main_hand : new Weapons::Dagger
      sub_hand : null
      body : null

  change_skill: ()->
    if @status.hp < 10
      last = @selected_skill
      @selected_skill = @skills['two']
      if last is @skills['one']
        @selected_skill.ct = 0
    else
      @selected_skill = @skills['one']

  die : (actor)->
    super actor
    actor.get_item new Weapons::Dagger

  exec:(actor,objs)->
    super actor,objs
    if actor.has_target()
      actor.targeting_obj.add_animation new Anim.prototype[@effect] amount, @size

class Player extends Character
  scale : 8
  name : "Player"
  constructor: (@scene, @x,@y,@group=ObjectGroup.Player) ->
    super(@x,@y,@group)
    @keys = {}
    @status = new Status
      str: 10
      int: 10
      dex: 10
    @skills =
      one: new Skill_Atack(@)
      two: new Skill_Smash(@)
      three: new Skill_Heal(@)
      four: new Skill_Meteor(@)
    @selected_skill = @skills['one']
    @_equips_ =
      main_hand : new Weapons::Blade
      sub_hand : null
      body : null

    @mouse = @scene.core.mouse

  getkey: (which,to) ->
    switch which
      when 68,39 then @keys.right = to
      when 65,37 then @keys.left = to
      when 87,38 then @keys.up = to
      when 83,40 then @keys.down = to
      when 32 then @keys.space = to
      when 17 then @keys.ctrl = to
      when 48 then @keys.zero = to
      when 49 then @keys.one = to
      when 50 then @keys.two = to
      when 51 then @keys.three = to
      when 52 then @keys.four = to
      when 53 then @keys.five = to
      when 54 then @keys.sixe = to
      when 55 then @keys.seven = to
      when 56 then @keys.eight = to
      when 57 then @keys.nine = to
    @keys[String.fromCharCode(which).toLowerCase()] = to

  change_skill: ()->
    @set_skill @scene.core.keys

  update:(objs, cmap)->
    enemies = @find_obj(ObjectGroup.get_against(@),objs,@status.sight_range)
    if @keys.space == 2
      @shift_target(enemies)
    super objs,cmap

  set_mouse_dir: (x,y)->
    rx = x - 320
    ry = y - 240
    if rx > 0
      @dir = Math.atan( ry / rx  )
    else
      @dir = Math.PI - Math.atan( ry / - rx  )

  move: (objs,cmap)->
    # @dir = @set_mouse_dir(mouse.x , mouse.y)
    keys = @keys

    if keys.right + keys.left + keys.up + keys.down > 1
      move = ~~(@status.speed * Math.sqrt(2)/2)
    else
      move = @status.speed

    if keys.right
      if cmap.collide( @x+move , @y )
        @x = (~~(@x/cmap.cell)+1)*cmap.cell-1
      else
        @x += move
    if keys.left
      if cmap.collide( @x-move , @y )
        @x = (~~(@x/cmap.cell))*cmap.cell+1
      else
        @x -= move
    if keys.up
      if cmap.collide( @x , @y-move )
        @y = (~~(@y/cmap.cell))*cmap.cell+1
      else
        @y -= move
    if keys.down
      if cmap.collide( @x , @y+move )
        @y = (~~(@y/cmap.cell+1))*cmap.cell-1
      else
        @y += move

ObjectGroup =
  Player : 0
  Enemy  : 1
  Item   : 2
  is_battler : (group_id)->
    group_id in [@Player, @Enemy]
  get_against : (obj)->
    switch obj.group
      when @Player
        return @Enemy
      when @Enemy
        return @Player

class Status
  constructor: (params = {}, equips = {}, @lv = 1) ->
    @build_status(params,equips)

    @hp = @MAX_HP
    @sp = @MAX_SP
    @exp = 0
    @next_lv = @lv * 50

    @STR = params.str
    @INT = params.int
    @DEX = params.dex

  build_status:(params={},equips)->
    @MAX_HP = params.str*10
    @MAX_SP = params.int*10

    @atk = params.str
    @mgc = params.int
    @def = params.str / 10
    @res = params.int

    @regenerate = ~~(params.str/10)
    @sight_range = params.dex*20
    @speed = ~~(params.dex * 0.5)
  level_up: ()->
    @lv++
    [@STR++, @INT++ , @DEX++]
    @exp = 0
    @next_lv = @lv * 50
    @build_status str:@STR,int:@INT,dex:@DEX

  get_exp:(point)->
    @exp += point
    if @exp >= @next_lv
      @level_up()
      Sys::message 'you level up! to lv.'+@lv

  set_next_exp:()->
    @next_lv = @lv * 30

  onDamaged : (amount)->
  onHealed : (amount)->

# generated by src/equip.coffee
class Item
class EquipItem extends Item
  weight : 1
  a_slash : 0
  a_thrust : 0
  a_blow : 0
  a_fire : 0
  a_flost : 0
  a_magic : 0
  a_thunder : 0
  a_holy : 0
  a_darkness : 0
  r_slash : 0
  r_thrust : 0
  r_blow : 0
  r_fire : 0
  r_flost : 0
  r_magic : 0
  r_thunder : 0
  r_holy : 0
  r_darkness : 0



class Weapon extends EquipItem
  type : 'weapon'

class Armor extends EquipItem
  type : 'armor'

(Weapons={}).prototype =
  Dagger : class Dagger extends Weapon
    name : 'Dagger'
    at : "main_hand"
    a_slash:0.7
    weight : 0.2

  Blade : class Blade extends Weapon
    name : 'Blade'
    at : "main_hand"
    a_slash : 1.1
    weight : 2.9

  SmallShield : class SmallShield extends Weapon
    name : 'SmallShiled'
    at : "sub_hand"
    r_slash : 0.1

  ClothArmor : class ClothArmor extends Armor
    name : 'ClothArmor'
    at : "body"
    r_slash : 0.2

class UseItem extends Item
  type : 'use'
  effect : (actor)->


class ItemBox
  items : []
  serialize : ()->
    buf = []
    for i in @items
      buf.push for [k,v] in ([k,v] for k,v of i)
    if localStorage?
      localStorage.set JSON.stringify buf
    else
      @_storage_ = JSON.stringify buf

  load : (str)->
    console.log eval @_storage_

  add_item : (item)->

    @items.push item

  remove_item : (item)->
    @items.remove item
# generated by src/skills.coffee
class Skill
  constructor: (@actor,@lv=1) ->
    @_build(@lv)
    @MAX_CT = @CT * 30
    @ct = @MAX_CT

  charge:(is_selected)->
    if @ct < @MAX_CT
      if is_selected
        @ct += @fg_charge
      else
        @ct += @bg_charge
  update: (objs,keys)->
    for name,skill of @actor.skills
      skill.charge @, skill is @
    @exec objs

  exec:(objs)->
  _build:(lv)->
  _calc:(target)-> return 1
  _get_targets:(objs)-> return []

class DamageHit extends Skill
  range : 30
  auto: true
  CT : 1
  bg_charge : 0.2
  fg_charge : 1
  damage_rate : 1.0
  random_rate : 0.2
  effect : 'Slash'

  _calc_rate:(target,e)->
    @actor.get_param("a_#{e}") * (1-target.get_param("r_#{e}"))

  _get_random:()->
    randint(100*(1-@random_rate),100*(1+@random_rate))/100

  exec:(objs)->
    targets = @_get_targets(objs)
    if @ct >= @MAX_CT and targets.size() > 0
      for t in targets
        amount = @_calc t
        t.add_damage(@actor,amount)
        # t.add_animation new Anim.prototype[@effect] amount
      @ct = 0
      return true
    return false

class SingleHit extends DamageHit
  effect : 'Slash'
  _get_targets:(objs)->
    if @actor.has_target()
      if @actor.get_distance(@actor.targeting_obj) < @range
        return [ @actor.targeting_obj ]
    return []

  _calc : (target)->
    damage = ~~(@actor.status.STR * @_calc_rate(target,'slash'))
    ~~(damage*@damage_rate*@_get_random())

class AreaHit extends DamageHit
  effect : 'Burn'
  _get_targets:(objs)->
    return @actor.find_obj ObjectGroup.get_against(@actor), objs , @range
  _calc : (target)->
    return ~~(@actor.status.atk * target.status.def*@damage_rate*randint(100*(1-@random_rate),100*(1+@random_rate))/100)

class TargetAreaHit extends DamageHit
  effect : 'Burn'
  _get_targets:(objs)->
    if @actor.has_target()
      if @actor.get_distance(@actor.targeting_obj) < @range
        return @actor.targeting_obj.find_obj ObjectGroup.get_against(@actor), objs , @range
    []
  _calc : (target)->
    return ~~(@actor.status.atk * target.status.def*@damage_rate*randint(100*(1-@random_rate),100*(1+@random_rate))/100)

  exec:(objs)->
    res = super objs
    # if res
    #   @actor.targeting_obj.add_animation new Anim.prototype[@effect] null, @range*1.5

class Skill_Atack extends SingleHit
  name : "Atack"
  range : 60
  CT : 1
  auto: true
  bg_charge : 0.2
  fg_charge : 1
  damage_rate : 1.0
  random_rate : 0.2

  _build:(lv)->
    @range -= lv
    @CT -= lv/40
    @bg_charge += lv/20
    @fg_charge -= lv/20
    @damage_rate += lv/20

class Skill_Smash extends SingleHit
  name : "Smash"
  range : 60
  CT : 2
  damage_rate : 2.2
  random_rate : 0.5
  bg_charge : 0.5
  fg_charge : 1

  _build: (lv) ->
    @range -= lv
    @CT -= lv/10
    @bg_charge += lv/20
    @fg_charge -= lv/20
    @damage_rate += lv/20
  _calc : (target)->
    return ~~(@actor.status.atk * target.status.def*@damage_rate*randint(100*(1-@random_rate),100*(1+@random_rate))/100)

class Skill_Meteor extends AreaHit
  name : "Meteor"
  range : 80
  auto: true
  CT : 4
  damage_rate : 5
  random_rate : 0.1

  bg_charge : 0.5
  fg_charge : 1
  effect : 'Burn'

  _calc : (target)->
    return ~~(@actor.status.atk * target.status.def*@damage_rate*randint(100*(1-@random_rate),100*(1+@random_rate))/100)

class Skill_Heal extends Skill
  name : "Heal"
  range : 0
  auto: false
  CT : 4
  bg_charge : 0.5
  fg_charge : 1

  exec:()->
    target = @actor
    if @ct >= @MAX_CT
      target.status.hp += 30
      @ct = 0
      Sys::debug "do healing"

class Skill_ThrowBomb extends Skill
  name : "Throw Bomb"
  range : 120
  auto: true
  CT : 4
  bg_charge : 0.5
  fg_charge : 1
  constructor: (@lv=1) ->
    super(@lv)
    @range = 120
    @effect_range = 30

  exec:(objs,mouse)->
    if @ct >= @MAX_CT
      targets = mouse.find_obj(ObjectGroup.get_against(@actor), objs ,@range)
      if targets.size()>0
        for t in targets
          t.status.hp -= 20
        @ct = 0

####
# generated by src/scenes.coffee
# generated by src/object.coffee
#===== String =====
String::replaceAll = (org, dest) ->
  return @split(org).join(dest)

#===== Array =====
# Rubinize
Array::remove = (obj)-> @splice(@indexOf(obj),1)
Array::size = ()-> @.length
Array::first = ()-> @[0]
Array::last = ()-> @[@.length-1]
Array::each = Array::forEach

#===== UtilClass =====
Util = {}
Util.prototype =
  extend : (obj, mixin) ->
    obj[name] = method for name, method of mixin
    obj

  include : (klass, mixin) ->
    Util::extend klass.prototype, mixin

  dup : (obj)->
    f = ()->
    f.prototype = obj
    new f

include = Util::include
vows = require 'vows'
assert = require 'assert'

keys =
   left : 0
   right : 0
   up : 0
   down : 0
mouse =
  x : 320
  y : 240

p = console.log

vows.describe('Game Test').addBatch
  Item:
    topic: new ItemBox
    'get item':(t)->
      t.add_item new Dagger
      t.add_item new Blade
      console.log t.serialize()
  Equip:
    topic:
      player : new Player null,100,100,ObjectGroup.Player
      goblin:new Goblin null,100,100,ObjectGroup.Enemy
    'Set Status':(topic)->
      p = topic.player
      g = topic.goblin
      p.equip new Blade
      p.equip new SmallShield
      p.equip new ClothArmor
      g.equip new Dagger

  Combat:
    topic:
      player:new Player null,100,100,ObjectGroup.Player
      goblin:new Goblin null,100,100,ObjectGroup.Enemy
      map : new SampleMap()
    # 'Attack until Dead':(topic)->
    #   player = topic.player
    #   goblin = topic.goblin
    #   m = topic.map
    #   # while player.is_alive() and goblin.is_alive()
    #   player.update([player,goblin],m,keys,mouse)
    #   goblin.update([player,goblin],m)
    #   assert.isTrue( player.is_dead() or goblin.is_dead())

    # 'Exec Attack Skill':(topic)->
    #   player = topic.player
    #   goblin = topic.goblin
    #   m = topic.map
    #   while player.is_alive() and goblin.is_alive()
    #     player.update([player,goblin],m,keys,mouse)
    #     goblin.update([player,goblin],m)
    #   player.targeting_obj = goblin
    #   player.selected_skill = new Skill_Atack(player,4)
    #   player.selected_skill.exec(player,[goblin])
    #   assert.isTrue( goblin.status.MAX_HP > goblin.status.hp )
    #   assert.isTrue( player.selected_skill.lv is 4 )

  #   'TargetChange':(topic)->
  #     goblin2 = new Goblin 100,100,ObjectGroup.Enemy
  #     goblin2.name += 2
  #     objs = [topic.player,topic.goblin,goblin2]
  #     i.update(objs,topic.map,keys,mouse) for i in objs

  #     before = topic.player.targeting_obj.name
  #     topic.player.shift_target [topic.goblin,goblin2]
  #     after = topic.player.targeting_obj.name
  #     topic.player.shift_target [topic.goblin,goblin2]
  #     after2 = topic.player.targeting_obj.name
  #     assert.isTrue before isnt after
  #     assert.isTrue before is after2

  #   'Equiptment':(topic)->
  #     player = topic.player
  #     player._equips_ =
  #       main_hand: new Blade
  #       sub_hand: new SmallShield
  #       body: new ClothArmor
  #     player.equip new Blade

  #   ' - Use Skill':
  #     topic : (parent)->
  #       parent.player.targeting_obj = parent.goblin
  #       return {
  #         player : parent.player
  #         gen_targets :()->
  #           new Goblin parent.player.x,parent.player.y,ObjectGroup.get_against(parent.player) for _ in [1..3]
  #       }
  #     'Atack':(topic)->
  #       topic.player.selected_skill = new Skill_Atack topic.player
  #       topic.player.selected_skill.exec topic.gen_targets()
  #     'Meteor':(topic)->
  #       topic.player.selected_skill = new Skill_Meteor topic.player
  #       topic.player.selected_skill.exec topic.gen_targets()
  #     'Smash':(topic)->
  #       topic.player.selected_skill = new Skill_Smash topic.player
  #       topic.player.selected_skill.exec topic.gen_targets()


.export module


